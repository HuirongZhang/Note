# 树和二叉树

##### 遍历

###### 1.前序遍历

```java
public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res=new ArrayList(); 
        if(root==null){
            return res;
        }
        Stack<TreeNode> stack=new Stack();
        while(!stack.isEmpty()||root!=null){
            while(root!=null){
                res.add(root.val);
                stack.push(root);
                root=root.left;
            }
            root=stack.pop();
            root=root.right;
        }
        return res;
}

```

###### 2.中序遍历

```java
public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res=new ArrayList();
        if(root==null){
            return res;
        }
        Stack<TreeNode> stack=new Stack();
        while(!stack.isEmpty()||root!=null){
            while(root!=null){               
                stack.push(root);
                root=root.left;
            }
            root=stack.pop();
            res.add(root.val);
            root=root.right;
        }
        return res;
    }
```

###### 3.后序遍历

```java
public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res=new ArrayList();
        TreeNode p=root;
        TreeNode r=null;//记录最近访问的节点
        if(p==null){
            return res;
        }
        Stack<TreeNode> s=new Stack();
        while(p!=null||!s.isEmpty()){
            if(p!=null){
                s.push(p);
                p=p.left;
            }else{
                p=s.peek();
                if(p.right==null||r==p.right){//右子树不存在或者右子树刚被访问过
                    p=s.pop();
                    res.add(p.val);
                    r=p; //记录被访问节点
                    p=null;
                }else{
                    p=p.right;
                    s.push(p);
                    p=p.left;
                }
            }
        }
        return res;
    }
```

###### 4.层次遍历

```java
public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res=new ArrayList<List<Integer>>();
        if(root==null) return res;
        Queue<TreeNode> q = new LinkedList<TreeNode>();
        q.add(root);  
        while(!q.isEmpty()){
             List<Integer> level = new ArrayList<Integer>();
            int LevelSize = q.size();           
            for(int i=0;i<LevelSize;i++){
                root=q.poll();
                level.add(root.val);
                if(root.left!=null){
                    q.add(root.left);
                }
                if(root.right!=null){
                    q.add(root.right);
                }
            }
            res.add(level);
            
        } 
        return res; 
 }
```

