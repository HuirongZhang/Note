###### 3.[无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

解析：**滑动窗口** --**滑动窗口算法**的本质是**双指针法中的左右指针法**,滑动窗口算法是双指针法中的左右指针法更为形象的一种表达方式。

滑动窗口算法可以用以解决**数组、字符串**的**子元素**问题。所谓滑动窗口，就像描述的那样，可以理解成是一个会滑动的窗口，每次记录下窗口的状态，再找出符合条件的适合的窗口。它可以将嵌套的循环问题，更高效的解决。

找出从l开始的最长不重复子串，res存储最大长度，r指示子串的结尾，用set存储子串中的字符，r每次移动将字符加入set

优化1，当剩余长度已经小于res，提前结束

优化2，左指针每次移动时直接移到内层循环退出时导致重复的那个字符后一位

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
       Set<Character> set=new HashSet<>();//存储从l到r的子串字符
        int l=0,r=0,res=0;
        while(l<s.length()){
            if(res>s.length()-l-1)//长度减1才是下标
                break;//提前结束
            while(r<s.length()&&!set.contains(s.charAt(r))){
                set.add(s.charAt(r));
                r++;
            }
            res=Math.max(res,r-l);
            while(r<s.length()&&set.contains(s.charAt(r))){//
                set.remove(s.charAt(l));
                l++;
            }
        }
        return res;
    }
}
```

###### 11.[盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

```java
int l=0,r=height.length-1,res=0;
while(l<r){
      res= height[l]<height[r] ? Math.max(res,height[l++]*(r-l)):Math.max(res,height[r--]*(r-l));//l++先执行了错误
}
   return res;  
```

​     踩的一个坑--先`height[l++]`   再 `(r-l)`  导致 `l++` 已经执行再计算的 `l-r`

解析：双指针

```java
   public int maxArea(int[] height) {
     int l=0,r=height.length-1,res=0;
        while(l<r){
            res= height[l]<height[r] ? Math.max(res,(r-l)*height[l++]):Math.max(res,(r-l)*height[r--]);
        }
        return res;
    }
```

###### [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root==null) return true;
        return dfs(root.left,root.right);
    }
    public boolean dfs(TreeNode A,TreeNode B){
        if(A==null&&B==null) return true;
        if(A==null||B==null) return false;
        if(A.val!=B.val) return false;
        return dfs(A.left,B.right)&&dfs(A.right,B.left);
    }
}
```



###### 104.[二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

```java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return Math.max(maxDepth(root.left),maxDepth(root.right))+1;
    }
}
```

###### 110.[平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

解析：递归求二叉树最大深度时检验是否存在不平衡。

```java
class Solution {
private boolean result = true;

public boolean isBalanced(TreeNode root) {
    maxDepth(root);
    return result;
}

public int maxDepth(TreeNode root) {
    if (root == null) return 0;
    int l = maxDepth(root.left);
    int r = maxDepth(root.right);
    if (Math.abs(l - r) > 1) result = false;
    return 1 + Math.max(l, r);
}
}
```

###### [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

解析:

叶子节点的定义是左孩子和右孩子都为 null 时叫做叶子节点

- 当 root 节点左右孩子都为空时，返回 1
- 当 root 节点左右孩子有一个为空时，返回不为空的孩子节点的深度，因为这时只要有一个子节点不为空则不是叶子节点还需要往下寻找
- 当 root 节点左右孩子都不为空时，返回左右孩子较小深度的节点值

```java
class Solution {  
    public int minDepth(TreeNode root) {
        if(root==null) return 0;
        int ldepth=minDepth(root.left);
        int rdepth=minDepth(root.right);
        if(ldepth==0||rdepth==0)  return ldepth+rdepth+1;//左右孩子有一个为空时，返回不为空的孩子节点的深度
        return Math.min(ldepth,rdepth)+1;
    }  
}
```



###### 112.[路径总和](https://leetcode-cn.com/problems/path-sum/)

判断是否存在从根节点到叶子节点值和等于target，终止条件--叶子节点且节点值等于target遍历下来的剩余值不满足终止条件时，左右子树递归寻找。

```java
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root==null) return false;
        if(root.left==null&&root.right==null&&root.val==targetSum) return true;
        return (hasPathSum(root.left,targetSum-root.val)||hasPathSum(root.right,targetSum-root.val));
    }
}
```

###### 113.[路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

和112.[路径总和](https://leetcode-cn.com/problems/path-sum/)的不同在于需要把所有满足条件的路径返回，考虑吧深度优先搜索，把路径依次加入结果，若不满足终止条件则剔除

```java
class Solution {
    List<List<Integer>> res=new ArrayList<>();
    List<Integer> path=new ArrayList<>();
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
       dfs(root,0,targetSum);
       return res;
    }

    public void dfs(TreeNode root,int pathSum,int sum){
         if(root==null) return ;
         pathSum+=root.val;
         path.add(root.val);
         if(root.left==null&&root.right==null&&pathSum==sum)
            res.add(new ArrayList<>(path));

        dfs(root.left,pathSum,sum);
        dfs(root.right,pathSum,sum);
        path.remove(path.size()-1);////恢复现场，因为targetSum是局部变量，故无须恢复现场
    }
}
```

###### 226.[翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root==null) return null;
        TreeNode temp=root.right;
        root.right=root.left;
        root.left=temp;
        invertTree( root.left);
        invertTree(root.right);
        return root;
    }
}
```

###### [404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)

**递归法三部曲**

- 确定递归函数的参数和返回值
- 确定终止条件
- 确定单层递归的逻辑

```java
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {//从左往右计算左叶子节点之和
        if(root==null) return 0;
        if(isLeaf(root.left)) return root.left.val+sumOfLeftLeaves(root.right);//左叶子节点需从父节点开始判断
        return sumOfLeftLeaves(root.left)+sumOfLeftLeaves(root.right);
    }

    public boolean isLeaf(TreeNode node){//判断叶子节点
        if(node==null) return false;
        if(node.left==null&&node.right==null) return true;
        return false;
    }
}
```

```

```



###### [437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)

解析：首先我们的思路还是dfs,这里比较特殊的是起点不必是根节点，终点也不必是叶子节点，现在我们假设某一节点node，计算从node节点出发满足条件的路径条数 = node本身是否是一条 + `dfs(node.left,tempsum)+dfs(node.right,tempsum)`；但是在主方法我们还需要递归计算root左右子树所有节点开始的路径条数，所以结果+`pathSum(root.left,sum)+pathSum(root.right,sum)`.

```java
class Solution {
    
    public int pathSum(TreeNode root, int sum) { 
        int res=0;
        if(root==null) return res;       
        res=dfs(root,sum)+pathSum(root.left,sum)+pathSum(root.right,sum);  
        return res;  
    }
    public int dfs(TreeNode node, int sum){
        int res=0;
        if(node==null) return res;
        if(node.val==sum) res++;
        res+=dfs(node.left,sum-node.val)+dfs(node.right,sum-node.val);
        return res;
    }
}
```





###### 543.[二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/) 

解析：递归求二叉树最大深度时保存最大直径

```Java
class Solution {
    int max=0;
    public int diameterOfBinaryTree(TreeNode root) {
        if(root==null) return 0;
        MaxDepth(root);
        return max;
    }
    public int MaxDepth(TreeNode root){
        if(root==null) return 0;
        int leftdepth=MaxDepth(root.left);
        int rightdepth=MaxDepth(root.right);
        max=Math.max(max,leftdepth+rightdepth);
        return Math.max(leftdepth,rightdepth)+1;
    }
}
```

###### [572. 另一个树的子树](https://leetcode-cn.com/problems/subtree-of-another-tree/)

解析：与572类似，对二叉树s的子树，不仅可以从root开始，也可以从子节点开始，这类都需要在主方法递归计算左右子树

```java
class Solution {
    public boolean isSubtree(TreeNode s, TreeNode t) {
        if(s==null) return false;//需判断s是否为空是因为下面获取了s.left和s.right，否则会空指针异常
        return dfs(s,t)||isSubtree(s.left,t)||isSubtree(s.right,t);
    }
    public boolean dfs(TreeNode s, TreeNode t){
        if(s==null&&t==null) return true;
        if(s==null||t==null) return false;
        if(s.val!=t.val) return false;
        return dfs(s.left,t.left)&&(dfs(s.right,t.right));
    }
}
```



###### 617.[合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)

```java
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if(root1==null&&root2==null) return null;
        if(root1==null) return root2;
        if(root2==null) return root1;
        TreeNode root=new TreeNode(root1.val+root2.val);
        root.left=mergeTrees(root1.left,root2.left);
        root.right=mergeTrees(root1.right,root2.right);
        return root;
    }
}
```

###### [687. 最长同值路径](https://leetcode-cn.com/problems/longest-univalue-path/)

```java
class Solution {
    int res=0;
    public int longestUnivaluePath(TreeNode root) {       
        if(root==null) return res;
        dfs(root);
        return res;
    }

    public int dfs(TreeNode node){
        if(node==null)  return 0;
        int l=dfs(node.left);//左子节点目前的最长路径长度
        int r=dfs(node.right);//右子节点目前的最长路径长度
        int arrowLeft=0,arrowRight=0;//从节点 node 延伸出的最长箭头的长度
        if(node.left!=null&&node.left.val==node.val) arrowLeft=l+1;
        if(node.right!=null&&node.right.val==node.val) arrowRight=r+1;
        res=Math.max(res,arrowLeft+arrowRight);//当左右子树中存在一条与node值不一样的路径时，其arrow值为0
        return Math.max(arrowLeft, arrowRight);
    }
}
```

